import mmu { MMU }

enum Terminal {
    GB  // Original GameBoy (GameBoy Classic)
    GBP // GameBoy Pocket/GameBoy Light
    GBC // GameBoy Color
    SGB // Super GameBoy
}

enum Flag: u8 {
    Z = 0b1000_0000
    N = 0b0100_0000
    H = 0b0010_0000
    C = 0b0001_0000
}

class CPU {
    a: u8 // accumulator
    b: u8
    c: u8
    d: u8
    e: u8
    f: u8 // flags Z, N, H, C
    h: u8
    l: u8
    sp: u16 // Stack Pointer
    public pc: u16 // Program Counter
    ei: bool // IME
    public halted: bool
    public ticks: usize
    public breakpoint: u16?
    public paused: bool
    debug: bool
    debug_message: String
    previous_debug_message: String

    public function init(terminal: Terminal, debug: bool = false) throws -> CPU {
        mut s = StringBuilder::create()
        return CPU(
            a: match terminal {
                GB => 0x01
                GBP => 0xFF
                GBC => 0x11
                SGB => 0x01
            } as! u8
            b: 0x00
            c: 0x13
            d: 0x00
            e: 0xD8
            f: 0xB0
            h: 0x01
            l: 0x4D
            sp: 0xFFFE
            pc: 0x0100
            ei: true
            halted: false
            ticks: 0
            breakpoint: None
            paused: false
            debug
            debug_message: ""
            previous_debug_message: ""
        )
    }

    public function print_debug_info(mut this, opcode: u8, mmu: &mut MMU) throws {
        mut flags = ""
        if .get_flag(Flag::Z) {
            flags += "Z"
        } else {
            flags += "-"
        }
        if .get_flag(Flag::N) {
            flags += "N"
        } else {
            flags += "-"
        }
        if .get_flag(Flag::H) {
            flags += "H"
        } else {
            flags += "-"
        }
        if .get_flag(Flag::C) {
            flags += "C"
        } else {
            flags += "-"
        }

        if this.debug {
            println("{:0>12} [INTE: 0x{:X}, INTF: 0x{:X}] - {:04X}: OPCPDE({:02X}) NN({:02X} {:02X}) Flags: {} AF: {:02X}{:02X} BC: {:02X}{:02X} DE: {:02X}{:02X} HL: {:02X}{:02X} SP: {:04X} [IE: {}]| {}", .ticks, mmu.inte, mmu.intf.data, .pc, opcode, mmu.read(addr: .pc + 1), mmu.read(addr: .pc + 2), flags, .a, .f, .b, .c, .d, .e, .h, .l, .sp, .ei, .debug_message)
        }
        // 
        if mmu.serial_data1 == 0x81 {
            mut s = StringBuilder::create()
            s.append(mmu.serial_data0)
            .debug_message += s.to_string()
            mmu.write(addr: 0xFF02, value: 0x0)
        }

        if .debug_message != .previous_debug_message {
            println("DBG: {}", .debug_message)
            .previous_debug_message = .debug_message
        }

        if .breakpoint.has_value() and .pc == .breakpoint! {
            .paused = true
        }
    }

    function fetch(mut this, mmu: &mut MMU) throws -> u8 {
        let opcode = mmu.read(addr: .pc)
        .pc += 1
        return opcode
    }

    function fetch_word(mut this, mmu: &mut MMU) -> u16 {
        let word = mmu.read_word(addr: .pc)
        .pc += 2
        return word
    }

    function stack_push(mut this, mmu: &mut MMU, value: u16) {
        .sp -= 2
        mmu.write_word(addr: .sp, value)
    }

    function stack_pop(mut this, mmu: &mut MMU) -> u16{
        let result = mmu.read_word(addr: .sp)
        .sp += 2
        return result
    }

    function handle_interrupts(mut this, mmu: &mut MMU) -> u32 {
        if not .halted and not .ei {
            return 0
        }

        let intf = mmu.read(addr: 0xFF0F)
        let inte = mmu.read(addr: 0xFFFF)
        let ii = intf & inte

        // Make sure both interrupt request and interrupt enabled bits are set before continuing with the interrupt
        guard ii != 0x00 else {
            return 0
        }

        .halted = false
        if not .ei {
            return 0
        }
        
        .ei = false

        let n = trailing_zeros(ii)
        let int_flag = intf & ~(1 << n)
        mmu.write(addr: 0xFF0F, value: int_flag)
        .stack_push(mmu, value: .pc)
        .pc = 0x0040u16 | ((n as! u16) << 3)
        return 4
    }

    public function tick(mut this, mmu: &mut MMU) throws -> u32 {
        mut cycles: u32 = 0
        let c = .handle_interrupts(mmu)
        
        if c != 0 {
            cycles = c
        } else if .halted {
            cycles = 1
        } else {
            cycles = .execute(mmu)
        }
        
        .ticks += (cycles * 4) as! usize
        return cycles * 4
    }

    function set_flag(mut this, anon flag: Flag, value: bool) {
        if value {
            .f = .f | flag as! u8
        } else {
            .f = .f & ~flag as! u8
        }
    }

    function get_flag(this, anon flag: Flag) -> bool => (.f & (flag as! u8)) != 0
    function get_af(this) -> u16 => (.a as! u16) << 8 | .f
    function get_bc(this) -> u16 => (.b as! u16) << 8 | .c
    function get_de(this) -> u16 => (.d as! u16) << 8 | .e
    function get_hl(this) -> u16 => (.h as! u16) << 8 | .l

    function set_af(mut this, anon value: u16) {
        .a = (value >> 8) as! u8
        .f = (value & 0x00F0) as! u8
    }

    function set_bc(mut this, anon value: u16) {
        .b = (value >> 8) as! u8
        .c = (value & 0x00FF) as! u8
    }

    function set_de(mut this, anon value: u16) {
        .d = (value >> 8) as! u8
        .e = (value & 0x00FF) as! u8
    }

    function set_hl(mut this, anon value: u16) {
        .h = (value >> 8) as! u8
        .l = (value & 0x00FF) as! u8
    }

    function alu_add(mut this, anon n: u8, opcode: u8) {
        let a = .a
        let r = wrapping_add_u8(a, n)
        .set_flag(Flag::C, value: a as! u16 + n as! u16 > 0xFF)
        .set_flag(Flag::H, value: (a & 0x0F) + (n & 0x0F) > 0x0F)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        .a = r
    }

    function alu_adc(mut this, anon n: u8, opcode: u8) {
        let a = .a
        let c = .get_flag(Flag::C) as! u8
        let r = wrapping_add_u8(wrapping_add_u8(a, n), c)
        .set_flag(Flag::C, value: a as! u16 + n as! u16 + c as! u16 > 0xFF)
        .set_flag(Flag::H, value: (a & 0x0F) + (n & 0x0F) + (c & 0x0F) > 0x0F)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        .a = r
    }

    function alu_sub(mut this, anon n: u8, opcode: u8) {
        let a = .a
        let r = wrapping_sub_u8(a, n)
        .set_flag(Flag::C, value: (a as! u16) < (n as! u16))
        .set_flag(Flag::H, value: (a & 0x0F) < (n & 0x0F))
        .set_flag(Flag::N, value: true)
        .set_flag(Flag::Z, value: r == 0x00u8)
        .a = r
    }

    function alu_sbc(mut this, anon n: u8, opcode: u8) {
        let a = .a
        let c = .get_flag(Flag::C) as! u8
        let r = wrapping_sub_u8(wrapping_sub_u8(a, n),c)
        .set_flag(Flag::C, value: (a as! u16) < (n as! u16) + (c as! u16))
        .set_flag(Flag::H, value: (a & 0x0F) < (n & 0x0F) + c)
        .set_flag(Flag::N, value: true)
        .set_flag(Flag::Z, value: r == 0x00)
        .a = r
    }

    function alu_and(mut this, anon n: u8, opcode: u8) {
        let r = .a & n
        .set_flag(Flag::C, value: false)
        .set_flag(Flag::H, value: true)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        .a = r
    }

    function alu_or(mut this, anon n: u8, opcode: u8) {
        let r = .a | n
        .set_flag(Flag::C, value: false)
        .set_flag(Flag::H, value: false)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        .a = r
    }

    function alu_xor(mut this, anon n: u8, opcode: u8) {
        let r = .a ^ n
        .set_flag(Flag::C, value: false)
        .set_flag(Flag::H, value: false)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        .a = r
    }

    function alu_cp(mut this, anon n: u8, opcode: u8) {
        let r = .a
        .alu_sub(n, opcode)
        .a = r
    }

    function alu_inc(mut this, anon a: u8, opcode: u8) throws -> u8 {
        let r = wrapping_add_u8(a, 1)
        .set_flag(Flag::H, value: (a & 0x0F) + 0x01 > 0x0F)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        return r
    }

    function alu_dec(mut this, anon a: u8, opcode: u8) throws -> u8 {
        let r = wrapping_sub_u8(a, 1)
        .set_flag(Flag::H, value: trailing_zeros(a) >= 4)
        .set_flag(Flag::N, value: true)
        .set_flag(Flag::Z, value: r == 0x00)
        return r
    }

    function alu_add_hl(mut this, anon n: u16, opcode: u8) {
        let a = .get_hl()
        let r = unchecked_add(a, n)
        .set_flag(Flag::C, value: a > (0xFFFFu16 - n))
        .set_flag(Flag::H, value: (a & 0x0FFFu16) + (n & 0x0FFFu16) > 0x0FFFu16)
        .set_flag(Flag::N, value: false)
        .set_hl(value: r)
    }

    function alu_rlc(mut this, anon a: u8, opcode: u8) -> u8 {
        let c = (a & 0x80) >> 7 == 0x01
        let r = (a << 1) | c as! u8
        .set_flag(Flag::C, value: c)
        .set_flag(Flag::H, value: false)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        return r
    }

    function alu_rl(mut this, anon a: u8, opcode: u8) -> u8 {
        let c = (a & 0x80) >> 7 == 0x01
        let r = (a << 1) + .get_flag(Flag::C) as! u8
        .set_flag(Flag::C, value: c)
        .set_flag(Flag::H, value: false)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        return r
    }

    function alu_rrc(mut this, anon a: u8, opcode: u8) -> u8 {
        let c = (a & 0x01) == 0x01
        mut r = a >> 1
        if c {
            r = 0x80u8 | (a >> 1)
        }
        .set_flag(Flag::C, value: c)
        .set_flag(Flag::H, value: false)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        return r
    }

    function alu_rr(mut this, anon a: u8, opcode: u8) -> u8 {
        let c = (a & 0x01) == 0x01
        mut r = a >> 1
        if .get_flag(Flag::C) {
            r = 0x80u8 | (a >> 1)
        }
        .set_flag(Flag::C, value: c)
        .set_flag(Flag::H, value: false)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        return r
    }

    function alu_jr(mut this, anon n: u8, opcode) {
        let ni8 = convert_u8_to_i8(n)
        let ni32 = ni8 as! i32
        let pci32 = (.pc as! u32) as! i32
        let r = pci32 + ni32
        .pc = r as! u16
    }

    function alu_sla(mut this, anon a: u8, opcode) -> u8 {
        let c = ((a & 0x80) >> 7) == 0x01
        let r = a << 1
        .set_flag(Flag::C, value: c)
        .set_flag(Flag::H, value: false)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        return r
    }

    function alu_sra(mut this, anon a: u8, opcode) -> u8 {
        let c = (a & 0x01) == 0x01
        let r = (a >> 1) | (a & 0x80)
        .set_flag(Flag::C, value: c)
        .set_flag(Flag::H, value: false)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        return r
    }

    function alu_swap(mut this, anon a: u8, opcode) -> u8 {
        .set_flag(Flag::C, value: false)
        .set_flag(Flag::H, value: false)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: a == 0x00)
        return (a >> 4) | (a << 4)
    }

    function alu_srl(mut this, anon a: u8, opcode: u8) -> u8 {
        let c = (a & 0x01) == 0x01
        let r = a >> 1
        .set_flag(Flag::C, value: c)
        .set_flag(Flag::H, value: false)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value: r == 0x00)
        return r
    }

    function alu_bit(mut this, anon a: u8, anon b: u8, opcode: u8) {
        let value = (a & (1 << b)) == 0x00
        .set_flag(Flag::H, value: true)
        .set_flag(Flag::N, value: false)
        .set_flag(Flag::Z, value)
    }

    function alu_res(mut this, anon a: u8, anon b: u8, opcode: u8) -> u8 {
        return a & ~(1 << b)
    }

    function alu_set(mut this, anon a: u8, anon b: u8, opcode: u8) -> u8 {
        return a | (1 << b)
    }

    function ld_r8_n8(mut this, anon opcode: u8, mmu: &mut MMU) throws {
        match (opcode >> 3) & 7 {
            0u8 => { .b = .fetch(mmu) }
            1u8 => { .c = .fetch(mmu) }
            2u8 => { .d = .fetch(mmu) }
            3u8 => { .e = .fetch(mmu) }
            4u8 => { .h = .fetch(mmu) }
            5u8 => { .l = .fetch(mmu) }
            7u8 => { .a = .fetch(mmu) }
            else => {
                eprintln("Error decoding REG from opcode (ld_r8_n8) 0x{:X}", opcode)
                abort()
            }
        }
    }

    function ld_r8_hl(mut this, anon opcode: u8, mmu: &mut MMU) throws {
        let regname = [0u8: "B", 1u8: "C", 2u8: "D", 3u8: "E", 4u8: "H", 5u8: "L", 7u8: "A"]
        match (opcode >> 3) & 7 {
            0u8 => { .b = mmu.read(addr: .get_hl()) }
            1u8 => { .c = mmu.read(addr: .get_hl()) }
            2u8 => { .d = mmu.read(addr: .get_hl()) }
            3u8 => { .e = mmu.read(addr: .get_hl()) }
            4u8 => { .h = mmu.read(addr: .get_hl()) }
            5u8 => { .l = mmu.read(addr: .get_hl()) }
            7u8 => { .a = mmu.read(addr: .get_hl()) }
            else => {
                eprintln("Error decoding REG from opcode (ld_r_hl)")
                abort()
            }
        }
    }

    function ld_hl_r8(mut this, anon opcode: u8, mmu: &mut MMU) throws {
        let regname = [0u8: "B", 1u8: "C", 2u8: "D", 3u8: "E", 4u8: "H", 5u8: "L", 7u8: "A"]
        let value = match opcode & 7 {
            0u8 => .b
            1u8 => .c
            2u8 => .d
            3u8 => .e
            4u8 => .h
            5u8 => .l
            7u8 => .a
            else => {
                eprintln("Error decoding REG from opcode (ld_hl_r8) 0x{:X}", opcode)
                abort()
            }
        }
        mmu.write(addr: .get_hl(), value)
    }

    function ld_r8_r8(mut this, anon opcode: u8) throws {
        let value = match opcode & 7 {
            0u8 => .b
            1u8 => .c
            2u8 => .d
            3u8 => .e
            4u8 => .h
            5u8 => .l
            7u8 => .a
            else => {
                eprintln("Error decoding REG from opcode (ld_r8_r8) 0x{:X}", opcode)
                abort()
            }
        }
        match (opcode >> 3) & 7 {
            0u8 => { .b = value }
            1u8 => { .c = value }
            2u8 => { .d = value }
            3u8 => { .e = value }
            4u8 => { .h = value }
            5u8 => { .l = value }
            7u8 => { .a = value }
            else => {
                eprintln("Error decoding REG from opcode (ld_r8_r8) 0x{:X}", opcode)
                abort()
            }
        }
    }

    function execute(mut this, mmu: &mut MMU) throws -> u32 {
        .print_debug_info(opcode: mmu.read(addr: .pc), mmu)
            
        let opcode = .fetch(mmu)
        mut cycles: u32 = 0

        let op_cycles: [i64] = [
            1, 3, 2, 2, 1, 1, 2, 1, 5, 2, 2, 2, 1, 1, 2, 1, // 0
            0, 3, 2, 2, 1, 1, 2, 1, 3, 2, 2, 2, 1, 1, 2, 1, // 1
            2, 3, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 1, 1, 2, 1, // 2
            2, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, // 3
            1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // 4
            1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // 5
            1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // 6
            2, 2, 2, 2, 2, 2, 0, 2, 1, 1, 1, 1, 1, 1, 2, 1, // 7
            1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // 8
            1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // 9
            1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // a
            1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, // b
            2, 3, 3, 4, 3, 4, 2, 4, 2, 4, 3, 0, 3, 6, 2, 4, // c
            2, 3, 3, 0, 3, 4, 2, 4, 2, 4, 3, 0, 3, 0, 2, 4, // d
            3, 3, 2, 0, 0, 4, 2, 4, 4, 1, 4, 0, 0, 0, 2, 4, // e
            3, 3, 2, 1, 0, 4, 2, 4, 3, 2, 4, 1, 0, 0, 2, 4, // f
        ]

        let cb_cycles: [i64] = [
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 0
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 1
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 2
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 3
            2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, // 4
            2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, // 5
            2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, // 6
            2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, // 7
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 8
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // 9
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // a
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // b
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // c
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // d
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // e
            2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, // f
        ]

        match opcode {
            // LD Instructions
            // ==========================================================================================================

            // LD (r16), A
            0x02u8 => { mmu.write(addr: .get_bc(), value: .a) }
            0x12u8 => { mmu.write(addr: .get_de(), value: .a) }

            // LD A, (r16)
            0x0Au8 => { .a = mmu.read(addr: .get_bc()) }
            0x1Au8 => { .a = mmu.read(addr: .get_de()) }

            // LD (HL),n
            0x36u8 => {
                let addr = .get_hl()
                let value = .fetch(mmu)
                mmu.write(addr, value)
            }

            // LD A, (a16)
            0xFAu8 => {
                let addr = .fetch_word(mmu)
                .a = mmu.read(addr)
            }

            // LD (a16), A
            0xEAu8 => {
                let addr = .fetch_word(mmu)
                mmu.write(addr, value: .a)
            }

            // ld A,(FF00+n)
            0xF0u8 => {
                let addr = 0xFF00u16 | (.fetch(mmu) as! u16)
                .a = mmu.read(addr)
            }

            // ld (FF00+n),A
            0xE0u8 => {
                let addr = 0xFF00u16 | (.fetch(mmu) as! u16)
                mmu.write(addr, value: .a)
            }

            // ld A,(FF00+C)
            0xF2u8 => {
                let addr = 0xFF00u16 | (.c as! u16)
                .a = mmu.read(addr)
            }

            // ld (FF00+C),A
            0xE2u8 => {
                let addr = 0xFF00u16 | (.c as! u16)
                mmu.write(addr, value: .a)
            }

            // LD (HL+), A
            0x22u8 => {
                let addr = .get_hl()
                mmu.write(addr, value: .a)
                .set_hl(addr + 1)
            }

            // LD (HL-), A
            0x32u8 => {
                let addr = .get_hl()
                mmu.write(addr, value: .a)
                .set_hl(addr - 1)
            }

            // LD A, (HL+)
            0x2Au8 => {
                let addr = .get_hl()
                .a = mmu.read(addr)
                .set_hl(addr + 1)
            }

            // LD A, (HL-)
            0x3Au8 => {
                let addr = .get_hl()
                .a = mmu.read(addr)
                .set_hl(addr - 1)
            }

            // LD (d16), SP
            0x08u8 => {
                let addr = .fetch_word(mmu)
                mmu.write_word(addr, value: .sp)
            }

            // LD SP, d8
            0xF8u8 => {
                let a = .sp
                let b = .fetch(mmu)
                let r = wrapping_add_signed_u8_to_u16(a, b)
                .set_flag(Flag::C, value: (a & 0x00FF) + (b as! u16 & 0x00FF) > 0x00FF)
                .set_flag(Flag::H, value: (a & 0x000F) + (b as! u16 & 0x000F) > 0x000F)
                .set_flag(Flag::N, value: false)
                .set_flag(Flag::Z, value: false)
                .set_hl(r)
            }

            0xF9u8 => { .sp = .get_hl() }

            // ld rr,nn
            0x01u8 | 0x11u8 | 0x21u8 | 0x31u8 => { 
                let value = .fetch_word(mmu)
                match opcode {
                    0x01u8 => .set_bc(value)
                    0x11u8 => .set_de(value)
                    0x21u8 => .set_hl(value)
                    0x31u8 => { .sp = value }
                    else => {}
                }
            }

            // LD R8, HL
            0x46u8 | 0x4Eu8 | 0x56u8 | 0x5Eu8 | 0x66u8 | 0x6Eu8 | 0x7Eu8  => .ld_r8_hl(opcode, mmu)

            // LD R8, N8
            0x06u8 | 0x0Eu8 | 0x16u8 | 0x1Eu8 | 0x26u8 | 0x2Eu8 | 0x3Eu8 => .ld_r8_n8(opcode, mmu)

            // LD R8, R8
            0x40u8 | 0x41u8 | 0x42u8 | 0x43u8 | 0x44u8 | 0x45u8 | 0x47u8 | 0x48u8 | 0x49u8 | 0x4Au8 | 0x4Bu8 | 0x4Cu8 | 0x4Du8 | 0x4Fu8 => .ld_r8_r8(opcode)
            0x50u8 | 0x51u8 | 0x52u8 | 0x53u8 | 0x54u8 | 0x55u8 | 0x57u8 | 0x58u8 | 0x59u8 | 0x5Au8 | 0x5Bu8 | 0x5Cu8 | 0x5Du8 | 0x5Fu8 => .ld_r8_r8(opcode)
            0x60u8 | 0x61u8 | 0x62u8 | 0x63u8 | 0x64u8 | 0x65u8 | 0x67u8 | 0x68u8 | 0x69u8 | 0x6Au8 | 0x6Bu8 | 0x6Cu8 | 0x6Du8 | 0x6Fu8 => .ld_r8_r8(opcode)
            0x78u8 | 0x79u8 | 0x7Au8 | 0x7Bu8 | 0x7Cu8 | 0x7Du8 | 0x7Fu8 => .ld_r8_r8(opcode)

            0x70u8 => { mmu.write(addr: .get_hl(), value: .b) }
            0x71u8 => { mmu.write(addr: .get_hl(), value: .c) }
            0x72u8 => { mmu.write(addr: .get_hl(), value: .d) }
            0x73u8 => { mmu.write(addr: .get_hl(), value: .e) }
            0x74u8 => { mmu.write(addr: .get_hl(), value: .h) }
            0x75u8 => { mmu.write(addr: .get_hl(), value: .l) }
            0x77u8 => { mmu.write(addr: .get_hl(), value: .a) }
            // ==========================================================================================================

            // PUSH
            // ==========================================================================================================
            0xC5u8 => { .stack_push(mmu, value: .get_bc()) }
            0xD5u8 => { .stack_push(mmu, value: .get_de()) }
            0xE5u8 => { .stack_push(mmu, value: .get_hl()) }
            0xF5u8 => { .stack_push(mmu, value: .get_af()) }
            // ==========================================================================================================

            // POP
            // ==========================================================================================================
            0xC1u8 | 0xD1u8 | 0xE1u8 | 0xF1u8 => {
                let value = .stack_pop(mmu)
                match opcode {
                    0xC1u8 => {.set_bc(value)}
                    0xD1u8 => {.set_de(value)}
                    0xE1u8 => {.set_hl(value)}
                    0xF1u8 => {.set_af(value)}
                    else => {}
                }
            }
            // ==========================================================================================================

            // Arithmetic/Logical Instructions
            // ==========================================================================================================

            // ADD A, r8/d8
            0x80u8 => .alu_add(.b, opcode)
            0x81u8 => .alu_add(.c, opcode)
            0x82u8 => .alu_add(.d, opcode)
            0x83u8 => .alu_add(.e, opcode)
            0x84u8 => .alu_add(.h, opcode)
            0x85u8 => .alu_add(.l, opcode)
            0x86u8 => .alu_add(mmu.read(addr: .get_hl()), opcode)
            0x87u8 => .alu_add(.a, opcode)
            0xC6u8 => .alu_add(.fetch(mmu), opcode)

            // ADC A, r8/d8
            0x88u8 => .alu_adc(.b, opcode)
            0x89u8 => .alu_adc(.c, opcode)
            0x8Au8 => .alu_adc(.d, opcode)
            0x8Bu8 => .alu_adc(.e, opcode)
            0x8Cu8 => .alu_adc(.h, opcode)
            0x8Du8 => .alu_adc(.l, opcode)
            0x8Eu8 => .alu_adc(mmu.read(addr: .get_hl()), opcode)
            0x8Fu8 => .alu_adc(.a, opcode)
            0xCEu8 => .alu_adc(.fetch(mmu), opcode)

            // SUB A, r8/d8
            0x90u8 => .alu_sub(.b, opcode)
            0x91u8 => .alu_sub(.c, opcode)
            0x92u8 => .alu_sub(.d, opcode)
            0x93u8 => .alu_sub(.e, opcode)
            0x94u8 => .alu_sub(.h, opcode)
            0x95u8 => .alu_sub(.l, opcode)
            0x96u8 => .alu_sub(mmu.read(addr: .get_hl()), opcode)
            0x97u8 => .alu_sub(.a, opcode)
            0xD6u8 => .alu_sub(.fetch(mmu), opcode)

            // SBC A, r8/d8
            0x98u8 => .alu_sbc(.b, opcode)
            0x99u8 => .alu_sbc(.c, opcode)
            0x9Au8 => .alu_sbc(.d, opcode)
            0x9Bu8 => .alu_sbc(.e, opcode)
            0x9Cu8 => .alu_sbc(.h, opcode)
            0x9Du8 => .alu_sbc(.l, opcode)
            0x9Eu8 => .alu_sbc(mmu.read(addr: .get_hl()), opcode)
            0x9Fu8 => .alu_sbc(.a, opcode)
            0xDEu8 => .alu_sbc(.fetch(mmu), opcode)

            // AND A, r8/d8
            0xA0u8 => .alu_and(.b, opcode)
            0xA1u8 => .alu_and(.c, opcode)
            0xA2u8 => .alu_and(.d, opcode)
            0xA3u8 => .alu_and(.e, opcode)
            0xA4u8 => .alu_and(.h, opcode)
            0xA5u8 => .alu_and(.l, opcode)
            0xA6u8 => .alu_and(mmu.read(addr: .get_hl()), opcode)
            0xA7u8 => .alu_and(.a, opcode)
            0xE6u8 => .alu_and(.fetch(mmu), opcode)

            // OR A, r8/d8
            0xB0u8 => .alu_or(.b, opcode)
            0xB1u8 => .alu_or(.c, opcode)
            0xB2u8 => .alu_or(.d, opcode)
            0xB3u8 => .alu_or(.e, opcode)
            0xB4u8 => .alu_or(.h, opcode)
            0xB5u8 => .alu_or(.l, opcode)
            0xB6u8 => .alu_or(mmu.read(addr: .get_hl()), opcode)
            0xB7u8 => .alu_or(.a, opcode)
            0xF6u8 => .alu_or(.fetch(mmu), opcode)

            // XOR A, r8/d8
            0xA8u8 => .alu_xor(.b, opcode)
            0xA9u8 => .alu_xor(.c, opcode)
            0xAAu8 => .alu_xor(.d, opcode)
            0xABu8 => .alu_xor(.e, opcode)
            0xACu8 => .alu_xor(.h, opcode)
            0xADu8 => .alu_xor(.l, opcode)
            0xAEu8 => .alu_xor(mmu.read(addr: .get_hl()), opcode)
            0xAFu8 => .alu_xor(.a, opcode)
            0xEEu8 => .alu_xor(.fetch(mmu), opcode)

            // CP A, r8/d8
            0xB8u8 => .alu_cp(.b, opcode)
            0xB9u8 => .alu_cp(.c, opcode)
            0xBAu8 => .alu_cp(.d, opcode)
            0xBBu8 => .alu_cp(.e, opcode)
            0xBCu8 => .alu_cp(.h, opcode)
            0xBDu8 => .alu_cp(.l, opcode)
            0xBEu8 => .alu_cp(mmu.read(addr: .get_hl()), opcode)
            0xBFu8 => .alu_cp(.a, opcode)
            0xFEu8 => .alu_cp(.fetch(mmu), opcode)

            // INC r8
            0x04u8 => {.b = .alu_inc(.b, opcode)}
            0x0Cu8 => {.c = .alu_inc(.c, opcode)}
            0x14u8 => {.d = .alu_inc(.d, opcode)}
            0x1Cu8 => {.e = .alu_inc(.e, opcode)}
            0x24u8 => {.h = .alu_inc(.h, opcode)}
            0x2Cu8 => {.l = .alu_inc(.l, opcode)}
            0x34u8 => {
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_inc(v, opcode)
                mmu.write(addr, value)
            }
            0x3Cu8 => {.a = .alu_inc(.a, opcode)}

            // DEC r8
            0x05u8 => {.b = .alu_dec(.b, opcode)}
            0x0Du8 => {.c = .alu_dec(.c, opcode)}
            0x15u8 => {.d = .alu_dec(.d, opcode)}
            0x1Du8 => {.e = .alu_dec(.e, opcode)}
            0x25u8 => {.h = .alu_dec(.h, opcode)}
            0x2Du8 => {.l = .alu_dec(.l, opcode)}
            0x35u8 => {
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_dec(v, opcode)
                mmu.write(addr, value)
            }
            0x3Du8 => {.a = .alu_dec(.a, opcode)}

            // ADD HL, r16
            0x09u8 => .alu_add_hl(.get_bc(), opcode)
            0x19u8 => .alu_add_hl(.get_de(), opcode)
            0x29u8 => .alu_add_hl(.get_hl(), opcode)
            0x39u8 => .alu_add_hl(.sp, opcode)

            // ADD SP, d8
            0xE8u8 => {
                let a = .sp
                let b = .fetch(mmu)
                let r = wrapping_add_signed_u8_to_u16(a, b)
                .set_flag(Flag::C, value: (a & 0x00FF) + (b as! u16 & 0x00FF) > 0x00FF)
                .set_flag(Flag::H, value: (a & 0x000F) + (b as! u16 & 0x000F) > 0x000F)
                .set_flag(Flag::N, value: false)
                .set_flag(Flag::Z, value: false)
                .sp = r
            }

            // INC r16
            0x03u8 => { .set_bc(unchecked_add(.get_bc(), 1u16)) }
            0x13u8 => { .set_de(unchecked_add(.get_de(), 1u16)) }
            0x23u8 => { .set_hl(unchecked_add(.get_hl(), 1u16)) }
            0x33u8 => { .sp = unchecked_add(.sp, 1u16) }

            // DEC r16
            0x0bu8 => { .set_bc(wrapping_sub_u16(.get_bc(), 1)) }
            0x1bu8 => { .set_de(wrapping_sub_u16(.get_de(), 1)) }
            0x2bu8 => { .set_hl(wrapping_sub_u16(.get_hl(), 1)) }
            0x3bu8 => { .sp = wrapping_sub_u16(.sp, 1) }

            // DAA
            0x27u8 => {
                mut a = .a
                mut adjust = 0x00u8
                if .get_flag(Flag::C) {
                    adjust = 0x60u8
                }
                if .get_flag(Flag::H) {
                    adjust = adjust | 0x06u8
                }
                if not .get_flag(Flag::N) {
                    if (a & 0x0Fu8) > 0x09 {
                        adjust = adjust | 0x06u8
                    }
                    if a > 0x99u8 {
                        adjust = adjust | 0x60u8
                    }
                    a = wrapping_add_u8(a, adjust)
                } else {
                    a = wrapping_sub_u8(a, adjust)
                }
                
                .set_flag(Flag::C, value: adjust >= 0x60u8)
                .set_flag(Flag::H, value: false)
                .set_flag(Flag::Z, value: a == 0x00)
                .a = a
            }

            // CPL
            0x2Fu8 => {
                .a = ~.a
                .set_flag(Flag::H, value: true)
                .set_flag(Flag::N, value: true)
            }
            // ==========================================================================================================


            // CPU Control Instructions
            // ==========================================================================================================
            
            // NOP
            0x00u8 => { }

            // CCF
            0x3Fu8 => {
                let value = not .get_flag(Flag::C)
                .set_flag(Flag::C, value)
                .set_flag(Flag::H, value: false)
                .set_flag(Flag::N, value: false)
            }

            // SCF
            0x37u8 => {
                .set_flag(Flag::C, value: true)
                .set_flag(Flag::H, value: false)
                .set_flag(Flag::N, value: false)
            }

            // HALT
            0x76u8 => { .halted = true }

            // STOP
            0x10u8 => { }

            // DI
            0xF3u8 => {
                // println("IME - Disable Interrupt")
                .ei = false
            }

            // EI
            0xFBu8 => {
                // println("IME - Enable Interrupt")
                .ei = true
            }

            // RLCA
            0x07u8 => {
                .a = .alu_rlc(.a, opcode)
                .set_flag(Flag::Z, value: false)
            }

            // RLA
            0x17u8 => {
                .a = .alu_rl(.a, opcode)
                .set_flag(Flag::Z, value: false)
            }

            //RRCA
            0x0Fu8 => {
                .a = .alu_rrc(.a, opcode)
                .set_flag(Flag::Z, value: false)
            }

            // RRA
            0x1Fu8 => {
                .a = .alu_rr(.a, opcode)
                .set_flag(Flag::Z, value: false)
            }

            // JUMP
            0xC3u8 => { .pc = .fetch_word(mmu) }
            0xE9u8 => { .pc = .get_hl() }

            // JUMP IF
            0xC2u8 | 0xCAu8 | 0xD2u8 | 0xDAu8 => {
                let pc = .fetch_word(mmu)
                let cond = match opcode {
                    0xC2u8 => not .get_flag(Flag::Z)
                    0xCAu8 => .get_flag(Flag::Z)
                    0xD2u8 => not .get_flag(Flag::C)
                    0xDAu8 => .get_flag(Flag::C)
                    else => {
                        eprintln("INVALID OPCODE FOR JUMP")
                        abort()
                    }
                }
                if cond { .pc = pc }
            }

            // JR
            0x18u8 => { .alu_jr(.fetch(mmu), opcode) }

            // JR IF
            0x20u8 | 0x28u8 | 0x30u8 | 0x38u8 => {
                let cond = match opcode {
                    0x20u8 => not .get_flag(Flag::Z)
                    0x28u8 => .get_flag(Flag::Z)
                    0x30u8 => not .get_flag(Flag::C)
                    0x38u8 => .get_flag(Flag::C)
                    else => {
                        eprintln("PANIC AT THE DISCO")
                        abort()
                    }
                }
                let value = .fetch(mmu)
                if cond { .alu_jr(value, opcode) }
            }
            // ==========================================================================================================

            // CALL
            0xCDu8 => {
                .stack_push(mmu, value: .pc + 2)
                .pc = .fetch_word(mmu)
            }

            // CALL IF
            0xC4u8 | 0xCCu8 | 0xD4u8 | 0xDCu8 => {
                let cond = match opcode {
                    0xC4u8 => not .get_flag(Flag::Z)
                    0xCCu8 => .get_flag(Flag::Z)
                    0xD4u8 => not .get_flag(Flag::C)
                    0xDCu8 => .get_flag(Flag::C)
                    else => {
                        eprintln("PANIC: Invalid Code for Call If 0x{:X}", opcode)
                        abort()
                    }
                }
                let nn = .fetch_word(mmu)
                if cond {
                    .stack_push(mmu, value: .pc)
                    .pc = nn
                }
            }

            // RST
            0xC7u8 => {
                .stack_push(mmu, value: .pc)
                .pc = 0x00
            }
            0xCFu8 => {
                .stack_push(mmu, value: .pc)
                .pc = 0x08
            }
            0xD7u8 => {
                .stack_push(mmu, value: .pc)
                .pc = 0x10
            }
            0xDFu8 => {
                .stack_push(mmu, value: .pc)
                .pc = 0x18
            }
            0xE7u8 => {
                .stack_push(mmu, value: .pc)
                .pc = 0x20
            }
            0xEFu8 => {
                .stack_push(mmu, value: .pc)
                .pc = 0x28
            }
            0xF7u8 => {
                .stack_push(mmu, value: .pc)
                .pc = 0x30
            }
            0xFFu8 => {
                .stack_push(mmu, value: .pc)
                .pc = 0x38
            }

            // RET
            0xC9u8 => { .pc = .stack_pop(mmu) }

            // RET IF
            0xC0u8 | 0xC8u8 | 0xD0u8 | 0xD8u8 => {
                let cond = match opcode {
                    0xC0u8 => not .get_flag(Flag::Z)
                    0xC8u8 => .get_flag(Flag::Z)
                    0xD0u8 => not .get_flag(Flag::C)
                    0xD8u8 => .get_flag(Flag::C)
                    else => {
                        eprintln("PANIC: Invalid Code for Call If 0x{:X}", opcode)
                        abort()
                    }
                }
                if cond { .pc = .stack_pop(mmu) }
            }

            // RETI
            0xD9u8 => {
                .ei = true
                .pc = .stack_pop(mmu)
            }

            // Extended Bit Operations
            0xCBu8 => { .extended_bit_operations(mmu, opcode) }

            // Unimplemented OpCodes
            0xd3u8 => panic_opcode("Opcode 0xd3 is not implemented", opcode)
            0xdbu8 => panic_opcode("Opcode 0xdb is not implemented", opcode)
            0xddu8 => panic_opcode("Opcode 0xdd is not implemented", opcode)
            0xe3u8 => panic_opcode("Opcode 0xe3 is not implemented", opcode)
            0xe4u8 => panic_opcode("Opcode 0xd4 is not implemented", opcode)
            0xebu8 => panic_opcode("Opcode 0xeb is not implemented", opcode)
            0xecu8 => panic_opcode("Opcode 0xec is not implemented", opcode)
            0xedu8 => panic_opcode("Opcode 0xed is not implemented", opcode)
            0xf4u8 => panic_opcode("Opcode 0xf4 is not implemented", opcode)
            0xfcu8 => panic_opcode("Opcode 0xfc is not implemented", opcode)
            0xfdu8 => panic_opcode("Opcode 0xfd is not implemented", opcode)

            else => {
                panic_opcode("Ilegal/Not Implemented instruction", opcode)
            }
        }

        let extra_cycles = match opcode {
            0x20u8 | 0x30u8 => {
                mut c: i64 = 0x01
                if .get_flag(Flag::Z) {
                    c = 0x00
                }
                yield c
            }
            0x28u8 | 0x38u8 => {
                mut c: i64 = 0x00
                if .get_flag(Flag::Z) {
                    c = 0x01
                }
                yield c
            }
            0xC0u8 | 0xD0u8 => {
                mut c: i64 = 0x03
                if .get_flag(Flag::Z) {
                    c = 0x00
                }
                yield c
            }
            0xC8u8 | 0xCCu8 | 0xD8u8 | 0xDCu8 => {
                mut c: i64 = 0x00
                if .get_flag(Flag::Z) {
                    c = 0x03
                }
                yield c
            }
            0xC2u8 | 0xD2u8 => {
                mut c: i64 = 0x01
                if .get_flag(Flag::Z) {
                    c = 0x00
                }
                yield c
            }
            0xCAu8 | 0xDAu8 => {
                mut c: i64 = 0x00
                if .get_flag(Flag::Z) {
                    c = 0x01
                }
                yield c
            }
            0xC4u8 | 0xD4u8 => {
                mut c: i64 = 0x03
                if .get_flag(Flag::Z) {
                    c = 0x00
                }
                yield c
            }
            else => 0x00i64
        }

        if opcode == 0xCBu8 {
            return cb_cycles[opcode]
        } else {
            return op_cycles[opcode] + extra_cycles
        }
    }

    function extended_bit_operations(mut this, mmu: &mut MMU, opcode: u8) throws {

        let cb = mmu.read(addr: .pc)
        .pc += 1
        match cb {
            // RLC r8
            0x00u8 => { .b = .alu_rlc(.b, opcode) }
            0x01u8 => { .c = .alu_rlc(.c, opcode) }
            0x02u8 => { .d = .alu_rlc(.d, opcode) }
            0x03u8 => { .e = .alu_rlc(.e, opcode) }
            0x04u8 => { .h = .alu_rlc(.h, opcode) }
            0x05u8 => { .l = .alu_rlc(.l, opcode) }
            0x06u8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_rlc(v, opcode)
                mmu.write(addr, value)
            }
            0x07u8 => { .a = .alu_rlc(.a, opcode) }

            // RRC r8
            0x08u8 => { .b = .alu_rrc(.b, opcode) }
            0x09u8 => { .c = .alu_rrc(.c, opcode) }
            0x0Au8 => { .d = .alu_rrc(.d, opcode) }
            0x0Bu8 => { .e = .alu_rrc(.e, opcode) }
            0x0Cu8 => { .h = .alu_rrc(.h, opcode) }
            0x0Du8 => { .l = .alu_rrc(.l, opcode) }
            0x0Eu8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_rrc(v, opcode)
                mmu.write(addr, value)
            }
            0x0Fu8 => { .a = .alu_rrc(.a, opcode) }

            // RL r8
            0x10u8 => { .b = .alu_rl(.b, opcode) }
            0x11u8 => { .c = .alu_rl(.c, opcode) }
            0x12u8 => { .d = .alu_rl(.d, opcode) }
            0x13u8 => { .e = .alu_rl(.e, opcode) }
            0x14u8 => { .h = .alu_rl(.h, opcode) }
            0x15u8 => { .l = .alu_rl(.l, opcode) }
            0x16u8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_rl(v, opcode)
                mmu.write(addr, value)
            }
            0x17u8 => { .a = .alu_rl(.a, opcode) }

            // RR r8
            0x18u8 => { .b = .alu_rr(.b, opcode) }
            0x19u8 => { .c = .alu_rr(.c, opcode) }
            0x1Au8 => { .d = .alu_rr(.d, opcode) }
            0x1Bu8 => { .e = .alu_rr(.e, opcode) }
            0x1Cu8 => { .h = .alu_rr(.h, opcode) }
            0x1Du8 => { .l = .alu_rr(.l, opcode) }
            0x1Eu8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_rr(v, opcode)
                mmu.write(addr, value)
            }
            0x1Fu8 => { .a = .alu_rr(.a, opcode) }

            // SLA r8
            0x20u8 => { .b = .alu_sla(.b, opcode) }
            0x21u8 => { .c = .alu_sla(.c, opcode) }
            0x22u8 => { .d = .alu_sla(.d, opcode) }
            0x23u8 => { .e = .alu_sla(.e, opcode) }
            0x24u8 => { .h = .alu_sla(.h, opcode) }
            0x25u8 => { .l = .alu_sla(.l, opcode) }
            0x26u8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_sla(v, opcode)
                mmu.write(addr, value)
            }
            0x27u8 => { .a = .alu_sla(.a, opcode) }

            // SRA r8
            0x28u8 => { .b = .alu_sra(.b, opcode) }
            0x29u8 => { .c = .alu_sra(.c, opcode) }
            0x2Au8 => { .d = .alu_sra(.d, opcode) }
            0x2Bu8 => { .e = .alu_sra(.e, opcode) }
            0x2Cu8 => { .h = .alu_sra(.h, opcode) }
            0x2Du8 => { .l = .alu_sra(.l, opcode) }
            0x2Eu8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_sra(v, opcode)
                mmu.write(addr, value)
            }
            0x2Fu8 => { .a = .alu_sra(.a, opcode) }

            // SWAP r8
            0x30u8 => { .b = .alu_swap(.b, opcode) }
            0x31u8 => { .c = .alu_swap(.c, opcode) }
            0x32u8 => { .d = .alu_swap(.d, opcode) }
            0x33u8 => { .e = .alu_swap(.e, opcode) }
            0x34u8 => { .h = .alu_swap(.h, opcode) }
            0x35u8 => { .l = .alu_swap(.l, opcode) }
            0x36u8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_swap(v, opcode)
                mmu.write(addr, value)
            }
            0x37u8 => { .a = .alu_swap(.a, opcode) }

            // SRL r8
            0x38u8 => { .b = .alu_srl(.b, opcode) }
            0x39u8 => { .c = .alu_srl(.c, opcode) }
            0x3Au8 => { .d = .alu_srl(.d, opcode) }
            0x3Bu8 => { .e = .alu_srl(.e, opcode) }
            0x3Cu8 => { .h = .alu_srl(.h, opcode) }
            0x3Du8 => { .l = .alu_srl(.l, opcode) }
            0x3Eu8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_srl(v, opcode)
                mmu.write(addr, value)
            }
            0x3Fu8 => { .a = .alu_srl(.a, opcode) }

            // BIT b, r8
            0x40u8 => { .alu_bit(.b, 0, opcode) }
            0x41u8 => { .alu_bit(.c, 0, opcode) }
            0x42u8 => { .alu_bit(.d, 0, opcode) }
            0x43u8 => { .alu_bit(.e, 0, opcode) }
            0x44u8 => { .alu_bit(.h, 0, opcode) }
            0x45u8 => { .alu_bit(.l, 0, opcode) }
            0x46u8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                .alu_bit(v, 0, opcode)
            }
            0x47u8 => { .alu_bit(.a, 0, opcode) }
            0x48u8 => { .alu_bit(.b, 1, opcode) }
            0x49u8 => { .alu_bit(.c, 1, opcode) }
            0x4Au8 => { .alu_bit(.d, 1, opcode) }
            0x4Bu8 => { .alu_bit(.e, 1, opcode) }
            0x4Cu8 => { .alu_bit(.h, 1, opcode) }
            0x4Du8 => { .alu_bit(.l, 1, opcode) }
            0x4Eu8 => {
                let addr = .get_hl()
                let v = mmu.read(addr)
                .alu_bit(v, 1, opcode)
            }
            0x4Fu8 => { .alu_bit(.a, 1, opcode) }
            0x50u8 => { .alu_bit(.b, 2, opcode) }
            0x51u8 => { .alu_bit(.c, 2, opcode) }
            0x52u8 => { .alu_bit(.d, 2, opcode) }
            0x53u8 => { .alu_bit(.e, 2, opcode) }
            0x54u8 => { .alu_bit(.h, 2, opcode) }
            0x55u8 => { .alu_bit(.l, 2, opcode) }
            0x56u8 => {
                let addr = .get_hl()
                let v = mmu.read(addr)
                .alu_bit(v, 2, opcode)
            }
            0x57u8 => { .alu_bit(.a, 2, opcode) }
            0x58u8 => { .alu_bit(.b, 3, opcode) }
            0x59u8 => { .alu_bit(.c, 3, opcode) }
            0x5Au8 => { .alu_bit(.d, 3, opcode) }
            0x5Bu8 => { .alu_bit(.e, 3, opcode) }
            0x5Cu8 => { .alu_bit(.h, 3, opcode) }
            0x5Du8 => { .alu_bit(.l, 3, opcode) }
            0x5Eu8 => {
                let addr = .get_hl()
                let v = mmu.read(addr)
                .alu_bit(v, 3, opcode)
            }
            0x5Fu8 => { .alu_bit(.a, 3, opcode) }
            0x60u8 => { .alu_bit(.b, 4, opcode) }
            0x61u8 => { .alu_bit(.c, 4, opcode) }
            0x62u8 => { .alu_bit(.d, 4, opcode) }
            0x63u8 => { .alu_bit(.e, 4, opcode) }
            0x64u8 => { .alu_bit(.h, 4, opcode) }
            0x65u8 => { .alu_bit(.l, 4, opcode) }
            0x66u8 => {
                let addr = .get_hl()
                let v = mmu.read(addr)
                .alu_bit(v, 4, opcode)
            }
            0x67u8 => { .alu_bit(.a, 4, opcode) }
            0x68u8 => { .alu_bit(.b, 5, opcode) }
            0x69u8 => { .alu_bit(.c, 5, opcode) }
            0x6Au8 => { .alu_bit(.d, 5, opcode) }
            0x6Bu8 => { .alu_bit(.e, 5, opcode) }
            0x6Cu8 => { .alu_bit(.h, 5, opcode) }
            0x6Du8 => { .alu_bit(.l, 5, opcode) }
            0x6Eu8 => {
                let addr = .get_hl()
                let v = mmu.read(addr)
                .alu_bit(v, 5, opcode)
            }
            0x6Fu8 => { .alu_bit(.a, 5, opcode) }
            0x70u8 => { .alu_bit(.b, 6, opcode) }
            0x71u8 => { .alu_bit(.c, 6, opcode) }
            0x72u8 => { .alu_bit(.d, 6, opcode) }
            0x73u8 => { .alu_bit(.e, 6, opcode) }
            0x74u8 => { .alu_bit(.h, 6, opcode) }
            0x75u8 => { .alu_bit(.l, 6, opcode) }
            0x76u8 => {
                let addr = .get_hl()
                let v = mmu.read(addr)
                .alu_bit(v, 6, opcode)
            }
            0x77u8 => { .alu_bit(.a, 6, opcode) }
            0x78u8 => { .alu_bit(.b, 7, opcode) }
            0x79u8 => { .alu_bit(.c, 7, opcode) }
            0x7Au8 => { .alu_bit(.d, 7, opcode) }
            0x7Bu8 => { .alu_bit(.e, 7, opcode) }
            0x7Cu8 => { .alu_bit(.h, 7, opcode) }
            0x7Du8 => { .alu_bit(.l, 7, opcode) }
            0x7Eu8 => {
                let addr = .get_hl()
                let v = mmu.read(addr)
                .alu_bit(v, 7, opcode)
            }
            0x7Fu8 => { .alu_bit(.a, 7, opcode) }

            // RES b, r8
            0x80u8 => { .b = .alu_res(.b, 0, opcode) }
            0x81u8 => { .c = .alu_res(.c, 0, opcode) }
            0x82u8 => { .d = .alu_res(.d, 0, opcode) }
            0x83u8 => { .e = .alu_res(.e, 0, opcode) }
            0x84u8 => { .h = .alu_res(.h, 0, opcode) }
            0x85u8 => { .l = .alu_res(.l, 0, opcode) }
            0x86u8 => {
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_res(v, 0, opcode)
                mmu.write(addr, value)
            }
            0x87u8 => { .a = .alu_res(.a, 0, opcode) }
            0x88u8 => { .b = .alu_res(.b, 1, opcode) }
            0x89u8 => { .c = .alu_res(.c, 1, opcode) }
            0x8Au8 => { .d = .alu_res(.d, 1, opcode) }
            0x8Bu8 => { .e = .alu_res(.e, 1, opcode) } 
            0x8Cu8 => { .h = .alu_res(.h, 1, opcode) }
            0x8Du8 => { .l = .alu_res(.l, 1, opcode) }
            0x8Eu8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_res(v, 1, opcode)
                mmu.write(addr, value)
            }
            0x8Fu8 => { .a = .alu_res(.a, 1, opcode) }
            0x90u8 => { .b = .alu_res(.b, 2, opcode) }
            0x91u8 => { .c = .alu_res(.c, 2, opcode) }
            0x92u8 => { .d = .alu_res(.d, 2, opcode) }
            0x93u8 => { .e = .alu_res(.e, 2, opcode) }
            0x94u8 => { .h = .alu_res(.h, 2, opcode) }
            0x95u8 => { .l = .alu_res(.l, 2, opcode) }
            0x96u8 => { 
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_res(v, 2, opcode)
                mmu.write(addr, value)
            }
            0x97u8 => { .a = .alu_res(.a, 2, opcode) }
            0x98u8 => { .b = .alu_res(.b, 3, opcode) }
            0x99u8 => { .c = .alu_res(.c, 3, opcode) }
            0x9Au8 => { .d = .alu_res(.d, 3, opcode) }
            0x9Bu8 => { .e = .alu_res(.e, 3, opcode) }
            0x9Cu8 => { .h = .alu_res(.h, 3, opcode) }
            0x9Du8 => { .l = .alu_res(.l, 3, opcode) }
            0x9Eu8 => {  
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_res(v, 3, opcode)
                mmu.write(addr, value)
            }
            0x9Fu8 => { .a = .alu_res(.a, 3, opcode) }
            0xA0u8 => { .b = .alu_res(.b, 4, opcode) }
            0xA1u8 => { .c = .alu_res(.c, 4, opcode) }
            0xA2u8 => { .d = .alu_res(.d, 4, opcode) }
            0xA3u8 => { .e = .alu_res(.e, 4, opcode) }
            0xA4u8 => { .h = .alu_res(.h, 4, opcode) }
            0xA5u8 => { .l = .alu_res(.l, 4, opcode) }
            0xA6u8 => {  
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_res(v, 4, opcode)
                mmu.write(addr, value)
            }
            0xA7u8 => { .a = .alu_res(.a, 4, opcode) }
            0xA8u8 => { .b = .alu_res(.b, 5, opcode) }
            0xA9u8 => { .c = .alu_res(.c, 5, opcode) }
            0xAAu8 => { .d = .alu_res(.d, 5, opcode) }
            0xABu8 => { .e = .alu_res(.e, 5, opcode) }
            0xACu8 => { .h = .alu_res(.h, 5, opcode) }
            0xADu8 => { .l = .alu_res(.l, 5, opcode) }
            0xAEu8 => {  
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_res(v, 5, opcode)
                mmu.write(addr, value)
            }
            0xAFu8 => { .a = .alu_res(.a, 5, opcode) }
            0xB0u8 => { .b = .alu_res(.b, 6, opcode) }
            0xB1u8 => { .c = .alu_res(.c, 6, opcode) }
            0xB2u8 => { .d = .alu_res(.d, 6, opcode) }
            0xB3u8 => { .e = .alu_res(.e, 6, opcode) }
            0xB4u8 => { .h = .alu_res(.h, 6, opcode) }
            0xB5u8 => { .l = .alu_res(.l, 6, opcode) }
            0xB6u8 => {  
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_res(v, 6, opcode)
                mmu.write(addr, value)
            }
            0xB7u8 => { .a = .alu_res(.a, 6, opcode) }
            0xB8u8 => { .b = .alu_res(.b, 7, opcode) }
            0xB9u8 => { .c = .alu_res(.c, 7, opcode) }
            0xBAu8 => { .d = .alu_res(.d, 7, opcode) }
            0xBBu8 => { .e = .alu_res(.e, 7, opcode) }
            0xBCu8 => { .h = .alu_res(.h, 7, opcode) }
            0xBDu8 => { .l = .alu_res(.l, 7, opcode) }
            0xBEu8 => {  
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_res(v, 7, opcode)
                mmu.write(addr, value)
            }
            0xBFu8 => { .a = .alu_res(.a, 7, opcode) }

            // SET b, r8
            0xC0u8 => { .b = .alu_set(.b, 0, opcode) }
            0xC1u8 => { .c = .alu_set(.c, 0, opcode) }
            0xC2u8 => { .d = .alu_set(.d, 0, opcode) }
            0xC3u8 => { .e = .alu_set(.e, 0, opcode) }
            0xC4u8 => { .h = .alu_set(.h, 0, opcode) }
            0xC5u8 => { .l = .alu_set(.l, 0, opcode) }
            0xC6u8 => {  
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_set(v, 0, opcode)
                mmu.write(addr, value)
            }
            0xC7u8 => { .a = .alu_set(.a, 0, opcode) }
            0xC8u8 => { .b = .alu_set(.b, 1, opcode) }
            0xC9u8 => { .c = .alu_set(.c, 1, opcode) }
            0xCAu8 => { .d = .alu_set(.d, 1, opcode) }
            0xCBu8 => { .e = .alu_set(.e, 1, opcode) }
            0xCCu8 => { .h = .alu_set(.h, 1, opcode) }
            0xCDu8 => { .l = .alu_set(.l, 1, opcode) }
            0xCEu8 => {  
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_set(v, 1, opcode)
                mmu.write(addr, value)
            }
            0xCFu8 => { .a = .alu_set(.a, 1, opcode) }
            0xD0u8 => { .b = .alu_set(.b, 2, opcode) }
            0xD1u8 => { .c = .alu_set(.c, 2, opcode) }
            0xD2u8 => { .d = .alu_set(.d, 2, opcode) }
            0xD3u8 => { .e = .alu_set(.e, 2, opcode) }
            0xD4u8 => { .h = .alu_set(.h, 2, opcode) }
            0xD5u8 => { .l = .alu_set(.l, 2, opcode) }
            0xD6u8 => {   
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_set(v, 2, opcode)
                mmu.write(addr, value)
            }
            0xD7u8 => { .a = .alu_set(.a, 2, opcode) }
            0xD8u8 => { .b = .alu_set(.b, 3, opcode) }
            0xD9u8 => { .c = .alu_set(.c, 3, opcode) }
            0xDAu8 => { .d = .alu_set(.d, 3, opcode) }
            0xDBu8 => { .e = .alu_set(.e, 3, opcode) }
            0xDCu8 => { .h = .alu_set(.h, 3, opcode) }
            0xDDu8 => { .l = .alu_set(.l, 3, opcode) }
            0xDEu8 => {    
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_set(v, 3, opcode)
                mmu.write(addr, value)
            }
            0xDFu8 => { .a = .alu_set(.a, 3, opcode) }
            0xE0u8 => { .b = .alu_set(.b, 4, opcode) }
            0xE1u8 => { .c = .alu_set(.c, 4, opcode) }
            0xE2u8 => { .d = .alu_set(.d, 4, opcode) }
            0xE3u8 => { .e = .alu_set(.e, 4, opcode) }
            0xE4u8 => { .h = .alu_set(.h, 4, opcode) }
            0xE5u8 => { .l = .alu_set(.l, 4, opcode) }
            0xE6u8 => {    
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_set(v, 4, opcode)
                mmu.write(addr, value)
            }
            0xE7u8 => { .a = .alu_set(.a, 4, opcode) }
            0xE8u8 => { .b = .alu_set(.b, 5, opcode) }
            0xE9u8 => { .c = .alu_set(.c, 5, opcode) }
            0xEAu8 => { .d = .alu_set(.d, 5, opcode) }
            0xEBu8 => { .e = .alu_set(.e, 5, opcode) }
            0xECu8 => { .h = .alu_set(.h, 5, opcode) }
            0xEDu8 => { .l = .alu_set(.l, 5, opcode) }
            0xEEu8 => {    
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_set(v, 5, opcode)
                mmu.write(addr, value)
            }
            0xEFu8 => { .a = .alu_set(.a, 5, opcode) }
            0xF0u8 => { .b = .alu_set(.b, 6, opcode) }
            0xF1u8 => { .c = .alu_set(.c, 6, opcode) }
            0xF2u8 => { .d = .alu_set(.d, 6, opcode) }
            0xF3u8 => { .e = .alu_set(.e, 6, opcode) }
            0xF4u8 => { .h = .alu_set(.h, 6, opcode) }
            0xF5u8 => { .l = .alu_set(.l, 6, opcode) }
            0xF6u8 => {     
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_set(v, 6, opcode)
                mmu.write(addr, value)
            }
            0xF7u8 => { .a = .alu_set(.a, 6, opcode) }
            0xF8u8 => { .b = .alu_set(.b, 7, opcode) }
            0xF9u8 => { .c = .alu_set(.c, 7, opcode) }
            0xFAu8 => { .d = .alu_set(.d, 7, opcode) }
            0xFBu8 => { .e = .alu_set(.e, 7, opcode) }
            0xFCu8 => { .h = .alu_set(.h, 7, opcode) }
            0xFDu8 => { .l = .alu_set(.l, 7, opcode) }
            0xFEu8 => {     
                let addr = .get_hl()
                let v = mmu.read(addr)
                let value = .alu_set(v, 7, opcode)
                mmu.write(addr, value)
             }
            0xFFu8 => { .a = .alu_set(.a, 7, opcode) }
            else => { panic("Unreacheable") }
        }
    }
}

function wrapping_add_u8(anon a: u8, anon b: u8) -> u8 => unchecked_add(a, b)

function wrapping_sub_u8(anon a: u8, anon b: u8) -> u8 {
    if (a == 0x00u8) and (b == 0x00u8) {
        return 0x00u8
    } else if b == 0x00 {
        return a
    } else {
        return unchecked_add(a, (256u16-(b as! u16)) as! u8)
    }
}

function wrapping_sub_u16(anon a: u16, anon b: u16) -> u16 {
    if (a == 0x00u16) and (b == 0x00u16) {
        return 0x00u16
    } else if b == 0x00u16 {
        return a
    } else {
        return unchecked_add(a, (65536u32-(b as! u32)) as! u16)
    }
}

function convert_u8_to_i8(anon a: u8) -> i8 {
    if a >= 128u8 {
        return ((a as! i32) - 256i32) as! i8
    } else {
        return a as! i8
    }
}

function wrapping_add_signed_u8_to_u16(anon a: u16, anon b: u8) -> u16 {
    if b >= 0x80u8 {
        return wrapping_sub_u16(a, 256u16 - (b as! u16))
    } else {
        return unchecked_add(a, b as! u16)
    }
}

function panic_opcode(anon message: String, opcode: u8) throws {
    panic(format("[OP 0x{:X}] {}", opcode, message))
}

function panic(anon message: String) {
    eprintln(message)
    abort()
}

function trailing_zeros(anon mut x: u8) -> i64 {
    mut count = 0
    while ((x & 1) == 0) {
        x = x >> 1
        count++
    }

    return count
}
