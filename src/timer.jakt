struct Clock {
    period: u32
    n: u32
}

struct TimerRegister {
    div: u8
    tima: u8
    tma: u8
    tac: u8
}

struct Timer {
    registers: TimerRegister
    div_clock: Clock
    tma_clock: Clock

    public function init() => Timer(
        registers: TimerRegister(div: 0u8, tima: 0u8, tma: 0u8, tac: 0u8)
        div_clock: Clock(period: 256, n:0)
        tma_clock: Clock(period: 1024, n:0)
    )

    public function read(this, addr: u16) => match addr {
        0xFF04u16 => .registers.div
        0xFF05u16 => .registers.tima
        0xFF06u16 => .registers.tma
        0xFF07u16 => .registers.tac
        else => {
            eprintln("[TIMER] Unsupported address 0x{:x}", addr)
            abort()
        }
    }

    public function write(mut this, addr: u16, value: u8) {
        match addr {
            0xFF04u16 => {
                .registers.div = 0x00
                .div_clock.n = 0x00
            }
            0xFF05u16 => { .registers.tima = value }
            0xFF06u16 => { .registers.tma = value }
            0xFF07u16 => { .update_period(value) }
            else => {
                eprintln("Unsupported timer address")
                abort()
            }
        }
    }

    function update_period(mut this, value: u8) {
        if ((.registers.tac & 0x03) != (value & 0x03)) {
            .tma_clock.n = 0x00
            .tma_clock.period = match (value & 0x03) {
                0x00u8 => 1024u32
                0x01u8 => 16u32
                0x02u8 => 64u32
                0x03u8 => 256u32
                else => {
                    eprintln("Timer Panic: Invalid period")
                    abort()
                }
            }
            .registers.tima = .registers.tma
        }
        .registers.tac = value
    }
}